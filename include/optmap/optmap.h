#pragma once

#include <filesystem>

#include "optmap/SortedFeatureList.h"

#include <optmap/optmap_full.h>
#include <optmap/optmap_position.h>
#include <optmap/optmap_position_and_time.h>
#include <optmap/optmap_set_voxelization.h>

#include <optmap/Descriptor.h>
#include <optmap/OptmapPose.h>
#include <optmap/OptmapPoseArray.h>

class OptMapNode {
    public:
        OptMapNode(ros::NodeHandle node_handle);
        ~OptMapNode();

        int get_num_features() { return this->featureList.get_num_features(); }
        int get_num_features_all_features() { return this->featureList.get_num_features_all_features(); }

        // Finds the best `num_scans` features to build a submap of the area.
        // Optionally, the area can be specified by `x`, `y`, `z`, `r`, `t1`, and `t2`
        // where all scans must be within a radius `r` of `x`, `y`, `z` and have a time `t` such that `t1` <= `t` <= `t2`.
        // Returns a vector of feature indices, which can be used in downstream functions. Also sets `result_map`.
        void optimize_streaming(int num_scans, std::vector<float>* x=NULL, std::vector<float>* y=NULL, std::vector<float>* z=NULL, std::vector<float>* r=NULL,
                                ros::Time t1=ros::Time::MIN, ros::Time t2=ros::Time::MAX);

        // config
        void set_save_folder(std::string val)       { save_folder = val; }
        void set_save_features(bool val)            { save_features = val; }
        void set_publish_poses(bool val)            { publish_poses = val; }
        void set_save_poses(bool val)               { save_poses = val; }
        void set_publish_map(bool val)              { publish_map = val; }
        void set_save_map(bool val)                 { save_map = val; }
        void set_publish_scans(bool val)            { publish_scans = val; }
        void set_save_scans(bool val)               { save_scans = val; }
        void set_voxelization(float val)            { voxelize = val; }

    private:
        void clear_temp_pc_storage();

        void callbackPose(optmap::OptmapPoseConstPtr msg);
        void callbackDescriptor(optmap::DescriptorConstPtr msg);
        void callbackPointCloud(sensor_msgs::PointCloud2::ConstPtr pc);
        void callbackPoseUpdates(optmap::OptmapPoseArrayPtr msg);

        // Aggregates the pointclouds from the provided feature indices. Can optionally save or publish the full map, and / or save each scan if publish/save_map and save_scans are set to true
        pcl::PointCloud<pcl::PointXYZ>::Ptr build_pointcloud_map(const std::vector<int>& feature_indices);

        // Returns a list of poses given a set of feature indices. Can optionally publish the pose array if publish_poses is set to true
        geometry_msgs::PoseArray::Ptr build_pose_array(const std::vector<int>& feature_indices);

        // Save and/or publishs scans specified by `feature_indices`
        void export_scans(const std::vector<int>& feature_indices);

        // Saves features from optimization to disk
        void save_features_to_folder(const std::vector<int>& feature_indices);

        /*
        Computes a score for how well the submap generated by adding `new_feature_index` represents the entire map specified by the features in `feature_indices`.
        We only check the distances of the new scan and can use the previous values to fill in the rest.
        
        Returns a score, updates min_dists where `min_dists` is a vector of the minimum distances from each feature specified by `feature_indices` to a feature in the solution set.

        @param
            `new_feature_index`: the feature in `eval_feature_indices` that we're adding to the submap
        @param
            `eval_feature_indices`: indices of `featureList` to compute the score over.
        @param
            `num_eval_scans`: use the first `num_eval_scans` items in `eval_feature_indices` to compute the score
        @param
            `prev_min_dists`: the distances from each feature in `eval_feature_indices` to the closest scan in the current submap without `new_feature_index`
        @param
            `prev_score`: should be equal to `avg(prev_min_dists)`
        */
        inline float oracle_exemplar(int new_feature_index, const std::vector<int>& eval_feature_indices, int num_eval_scans, const std::vector<float>& prev_min_dists, float prev_score, float sample_traj_dist) {
            float exemplar_score = prev_score * sample_traj_dist;
            for (int i = 0; i < num_eval_scans; i++) {
                float dist = featureList.get_distance_between_descriptors(new_feature_index, eval_feature_indices[i]);
                if (dist < prev_min_dists[i]) {
                    exemplar_score -= featureList.get_element_weighting(eval_feature_indices[i]) * (prev_min_dists[i] - dist);
                }
            }
            return exemplar_score / sample_traj_dist;
        }
        
        void optimize_streaming_helper(std::vector<std::pair<int,float>> features, int num_scans);
        std::vector<int> gen_heur_sol(const std::vector<int>& feature_indices, int num_scans);
        float overlap_from_desc(float dist);
        float overlap_from_pose(const Feature::Pose& pose1, const Feature::Pose& pose2);

        void screen_output();
        void Debug();

        // synchronization
        void build_map_worker();
        std::thread build_map_thread;
        std::condition_variable build_map_cv;
        std::mutex build_map_inputs_mtx;
        std::atomic<bool> optimization_done;
        std::atomic<float> optimization_score;
        
        float worker_last_seen_optimization_score;
        int unchanged_iters_max;

        // optimization results
        std::vector<int> result_indices;
        pcl::PointCloud<pcl::PointXYZ>::Ptr result_map;

        // ROS
        ros::NodeHandle nh;

        // Subscribers
        ros::Subscriber pose_sub;
        ros::Subscriber descriptor_sub;
        ros::Subscriber pc_sub;
        ros::Subscriber pose_updates_sub;

        // Publishers
        ros::Publisher map_pub;
        ros::Publisher map_scans_pub;
        ros::Publisher poses_pub;
        ros::Publisher markers_pub;

        SortedFeatureList featureList;

        // track most recent id received of each type
        int most_recent_pose;
        int most_recent_desc;
        int most_recent_cloud;

        int num_threads;

        // output settings
        std::string pc_foldername;
        std::string save_folder;
        bool save_features;
        bool publish_poses;
        bool save_poses;
        bool publish_map;
        bool save_map;
        bool publish_scans;
        bool save_scans;

        // dynamic reordering
        bool d_r;
        float sorted_set_factor;
        float dist_heur_radius;

        // params
        std::string version;
        float unique_scan_dist;
        float fraction_eval_scans;
        float voxelize;
        std::string map_frame;
        bool debug;
        float x_min, x_max, y_min, y_max, z_min, z_max; // Crop box constraints

        // debug outputs
        std::string first_time;
        std::string last_time;
        int num_scans_output;
        float lower_bound;
        float upper_bound;
        float beta_output;
        int tot_num_features;
        int num_features;
        int num_sols;
        float best_sol_opt_guess;
        float best_sol_score;
        int size_of_best_sol;
        float init_sol_time;
        float optimization_time;
        float map_build_time;
        float max_mem_usage;

        double recent_time;

        int last_updated_pose_index;
        Feature::Pose last_del_pose;

        // for openmp reduction
        struct ScoreIndexPair {
            float score;
            int index;
        };
};
